# LC01

https://leetcode.com/problems/two-sum/

## 解法一

### 暴力法

```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
   int* result = (int*)malloc(2*sizeof(int));
    for(int i = 0; i < numsSize; ++i){
        for(int j = i + 1; j < numsSize; ++j){
            if(nums[i] + nums[j] == target){
                result[0] = i;
                result[1] = j;
                *returnSize = 2;
                return result;
            }
        }
    }
    *returnSize = 0;
    return result;
}
```

时间复杂度`O(n^2)`。

![截屏2020-10-27 下午8.14.07](/Users/ming/Library/Application Support/typora-user-images/截屏2020-10-27 下午8.14.07.png)

## 解法二

### 二分法

算法：当数据量很大适宜采用该方法。采用二分法查找时，**_数据需是排好序的_**。 

基本思想：假设数据是按升序排序的，对于给定值key，从序列的中间位置k开始比较，

- 如果当前位置arr[k]值等于key，则查找成功；

- 若key小于当前位置值arr[k]，则在数列的前半段中查找,arr[low,mid-1]；

- 若key大于当前位置值arr[k]，则在数列的后半段中继续查找arr[mid+1,high]，直到找到为止

时间复杂度:O(log(n))。

### C语言快排函数

包含在`stdlib.h`头文件中

```C
# include <stdlib.h>

qsort(*s, n, sizeof(s[0]), cmp);
//其中cmp函数写为
int cmp(const void *a, const void *b)
{
  return *(int*)a - *(int*)b;//从小到大排序
  //return *(int*)b - *(int *)a; 从大到小排序
}
//cmp函数的返回值：
//<=0（不进行置换），>0（进行置换）
```

> **对于`qsort`函数中的参数说明**：
>
> - `s` - 一个地址，即参与排序的首地址。
> - `n` - 需要排序的数量。
> - `sizeof(s[0])` - 每一个元素占用的空间大小。
> - `cmp`：指向函数的指针，用于确定排序的顺序。

### 源代码

```C
#include<stdlib.h>

int cmp(const void *a, const void *b)
{
    return *(int*)a - *(int*)b;
}

int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) 
{
    int *temp = (int *)malloc(numbersSize*sizeof(int));
    int *result=(int *)malloc(2*sizeof(int));
    for(int i=0;i<numbersSize;i++)
        temp[i] = numbers[i];
    qsort(temp, numbersSize, sizeof(int), cmp);
        
    int left=0, right=numbersSize-1;
    while(left < right)
    {
        if (temp[left] + temp[right] == target)
        {
            *returnSize=2;
            result[0]=left;
            result[1]=right;
            break;
        }
        else if (temp[left] + temp[right] < target)
            left++;
        else
            right--;
    }
  	//为了防止原数组中的元素相同
    int flagl = 0;
    int flagr = 0;
    for(int i=0; i<numbersSize; i++)
    {
        if (flagl == 0 && temp[result[0]] == numbers[i])
        {
            result[0] = i;
            flagl = 1;
        }
        else if(flagr == 0 && temp[result[1]] == numbers[i])
        {
            result[1] = i;
            flagr = 1;
        }
    }
    return result;
}

```

![截屏2020-10-27 下午8.16.17](/Users/ming/Library/Application Support/typora-user-images/截屏2020-10-27 下午8.16.17.png)

## 解法三

### 哈希表

